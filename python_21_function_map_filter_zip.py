#  функции map, filter, zip

# Функция map - позволяет преобразовывать элементы итерируемого объекта
# в соответствии с некоторой указанной функцией - map(func, *iterables)

# lst = [1,-2,3,-4,-5]              # есть упорядоченный список
                                    # мы хотим получить список из квадратов этих чисел
# создадим вспомогательную функцию  с названием sq
def sq(x):                          # функция sq будет принимать один аргумент x
    return x**2                     # возвращает на выходе **2 - квадрат

lst = [1, -2, 3, -4, -5]

b = map(sq, lst)                    # sq - функция которая будет преобразовывать элементы нашего списка
      # sq - ссылка на ф-цию        # lst - список который будет преобразовываться
# переменная b будет ссылаться на соответствующий итератор, перебирая его будем получать квадраты чисел, записанных в списке
print(b, type(b))                   # <map object at 0x000001E2F5367CA0> <class 'map'>

# т.к. map это объект - генератор, то мы можем выводить его значение с помощью ф-ции next
#print( next(b) )
#print( next(b) )
#print( next(b) )
#print( next(b) )
#print( next(b) )

# Сформируем на основе генератора b список и выведем его в консоль
a = list(b)
print("Cписок из квадратов чисел (Сформирован на основе генератора b список результатов): ", a)

# Функция map брала элементы этого списка lst по порядку 1, 2, 3... и к каждому элементу списка
# применяет ф-цию sq, и мы говорим что будем делать с этим элементом.
# Когда ф-ция map берет первый элемент, вместо x подставляется 1, эта 1 возводится в квадрат
# затем ф-ция sq возвращает это значение, и то что она возвратила, мы видим в качестве первого элемента списка a
# далее ф-ция sq берет второй элемент, вместо x подставляется -2, эта -2 возводится в квадрат
# затем ф-ция sq возвращает это значение, и т.д. до конца по порядку перебирая все элементы
# ф-ция map на выходе дает список состоящий из квадратов соответствующих чисел

# Функция map - в некотором смысле, это эквивалент выражения-генератора
b1 = (sq(x) for x in [1,-2,3,-4,-5])            
print(b1, type(b1)) 
b2 = (sq(x) for x in lst)                   # вместо списка подставлено lst - результат одинаковый
print(b2, type(b2)) 


# Функция sq - принимает только один аргумент x
# Возвращать мы можем несколько значений return x, x**2
def squ(x):                          # функция sq будет принимать один аргумент x
    return x, x**2                   # возвращает два значения, значение и **2 - квадрат
                                     # Функция sq - принимает только один аргумент x
# def sq(x, n):                      # функция sq может принимать только один аргумент x - так работать не будет
#    return x**n                     # возвращать может

                                     
lst1 = [11, -22, 33, -44, -55]

b3 = map(squ, lst1)                  # sq - функция которая будет преобразовывать элементы нашего списка
      # sq - ссылка на ф-цию         # lst - список который будет преобразовываться
# переменная b будет ссылаться на соответствующий итератор, перебирая его будем получать квадраты чисел, записанных в списке
print(b3, type(b3))                   # <map object at 0x000001E2F5367CA0> <class 'map'>

# Сформируем на основе генератора b список и выведем его в консоль
a1 = list(b3)
print("Cписок-кортеж из квадратов чисел (Сформирован на основе генератора b3 список результатов): ", a1)
print(type(a1))                     # <class 'list'> - получили список кортежей(_,_), значение и значение в квадрате


# Функция map - работа со строками
def sql(x):                          # функция sql будет принимать один аргумент x
    return x                         # возвращает одно значение

# у нас есть список из строк
# мы хотим получить длины этих строк
lst2 = ["Москва", "Рязань", "Смоленск", "Тверь", "Томск"]
b4 = map(len, lst2)                  # len - функция которая будет преобразовывать элементы нашего списка
       # len - ссылка на ф-цию       # lst2 - список который будет преобразовываться
       #     - ссылка может быть на стандартные функции
       #     - могут быть использованы методы строк
       # str.upper, lst2  - все строки будут записагы заглавными буквами
       # lambda x, lst    - 
                                     # переменная b4 будет ссылаться на соответствующий итератор, перебирая его будем получать длины строк в списке
print(b4, type(b4))                  # <map object at 0x000001E2F5367CA0> <class 'map'>

a2 = list(b4)
print("\nCписок lst2 состоит из строк [Москва, Рязань, Смоленск, Тверь, Томск]\n(сформируем на основе генератора b4)\nдлину строк: ", a2)

# lambda  - функция 
lst3 = ["Москва", "Рязань", "Смоленск", "Тверь", "Томск"]
b5 = map(lambda x: x[::-1], lst3)    # lambda - функция которая будет преобразовывать элементы нашего списка
       # lambda - ссылка на ф-цию    # lst3 - список который будет преобразовываться
       # первым аргументом ф-ции map часто указывается lambda ф-ция
       # lambda - обязательно указывается один аргумент x,
       # потому что ф-ция которая преобразовывает элементы этого списка должна принимать один аргумент
       # и далее мы говорим что будем делать : допустим преобразуем строки так,
       # чтоб были записаны в обратном порядке lambda x: x[::-1]
       # lambda x: x.replace("a", "A"), lst3  - заменяем малые буквы на болбшие
                                     # переменная b4 будет ссылаться на соответствующий итератор, перебирая его будем получать длины строк в списке
print(b5, type(b5))                  # <map object at 0x000001E2F5367CA0> <class 'map'>

a3 = list(b5)
print("\n lambda ф-ция - преобразуем строки так,\nчтоб были записаны в обратном порядке: ", a3)

# функция map принимает вторым аргументом (   ,lst3) принимает любой итерируемый объект
# в том числе итератор b5. Мы можем b5 указать в качестве второго аргумента, этой же самой ф-ции
# выполним еще раз ф-цию map, скажем что хотим отсортировать наши элементы, а сортировать будем результат b5
# Получим отсортированные символы строк по возростанию
# lambda  - функция 
lst4 = ["Москва", "Рязань", "Смоленск", "Тверь", "Томск"]
b6 = map(lambda x: x[::-1], lst4)    # lambda - функция которая будет преобразовывать элементы нашего списка
       # lambda - ссылка на ф-цию    # lst3 - список который будет преобразовываться
       # первым аргументом ф-ции map часто указывается lambda ф-ция
       # lambda - обязательно указывается один аргумент x,
       # потому что ф-ция которая преобразовывает элементы этого списка должна принимать один аргумент
       # и далее мы говорим что будем делать : допустим преобразуем строки так,
       # чтоб были записаны в обратном порядке lambda x: x[::-1]
       # lambda x: x.replace("a", "A"), lst4  - заменяем малые буквы на болбшие
                                     # переменная b4 будет ссылаться на соответствующий итератор, перебирая его будем получать длины строк в списке
print(b6, type(b6))                  # <map object at 0x000001E2F5367CA0> <class 'map'>

c = map(sorted, b6)                  # выполним еще раз ф-цию map, хотим отсортировать наши элементы,
                                     # сортироваить будем результа b6

a4 = list(c)
print("\n lambda ф-ция - преобразуем строки так,\nчтоб были записаны в обратном порядке\nотсортированы по возрастанию: ", a4)

# Строки которые были в b были изначально восприняты как коллекции "Москва", "Рязань", "Смоленск", "Тверь", "Томск"
# и для соответствующей коллекции мы получили сортировку 'М', 'а', 'в', 'к', 'о', 'с'.
# мы получили набор из вложенных списков

# Функция map - ввод с клавиатуры нескольких чисел через разделитель, например через пробел
# пробел является нецифровым символом, из за этого функция int вернет ошибку
a6 = input().split()                 # разбили нашу строку по разделителю
print("После ввода с клавиатуры нескольких чисел через разделитель\nполучим список из введенных значений\nтолько эти значения будут представлены в виде строк\n строки 1 и 2 нужно преобразовать в числа", a6)
#print( int(a6) )                    # Error - ф-ция int на входе ожидает конкретной строки а не списка из строк
                                     # Поэтому используем ф-цию map

a7 = map(int, input().split())       # разбили нашу строку по разделителю
print("После ввода с клавиатуры нескольких чисел через разделитель\nполучим объект генератор map\nс помощью ф-ции next будем получать значения 1 и 2, но лучше преобразуем к списку list", a7)


a8 = list(map(int, input().split())) # разбили нашу строку по разделителю
print("После ввода с клавиатуры нескольких чисел через разделитель\nполучим список из введенных значений \n представленных в виде ЧИСЕЛ:", a8)
print( a8 )                          # Error - ф-ция int на входе ожидает конкретной строки а не списка из строк

# Формат введения чисел через пробел - разделитель .split(";")
# Преобразует все наши введенные значения в коллекцию из чисел



# Ф-ция filter - удет возвращать элементы для которых переданная ф-ция func возвращает значение True 
# Предположим есть список a=[1,2,3,4,5,6,7,8,9,10] из которого нужно выбрать все нечетные значения
# Для этого определим ф-цию odd 
def odd(x):                         # ф-ция odd будет принимать один аргумент
    return x%2                      # возвращать True, если x нечетная , False - если x четная
                                    
a9 = [1,2,3,4,5,6,7,8,9,10]
                                    # далее применим ф-цию filter
b7 = filter(odd, a9)                # передаем ссылку на нашу ф-цию odd, а далее список к которому будет применяться данная ф-ция
print("На выходе получаем генератор",b7)

                                    # используем ф-цию next - для перебора значений генератора 
print( next(b7) )                   # 1 - в консоли значения в колонку выводятся
print( next(b7) )                   # 3    
print( next(b7) )                   # 5
print( next(b7) )                   # 7                 
             


                                    # используем цикл - для перебора значений генератора
def odd1(x):                        # ф-ция odd будет принимать один аргумент
    return x%2                      # возвращать True, если x нечетная , False - если x четная
                                    
a10 = [1,2,3,4,5,6,7,8,9,10]

                                    # применим ф-цию filter С ЦИКЛОМ ИЛИ БЕЗ    
#b8 = filter(odd, a10)              # фильтр с циклом
#print("Класс - filter с циклом",type(b8), b8)       # <class 'filter'><filter object at 0x000001EF46807580> 1 3 5 7 9 - получили объект генератор

b8 = list(filter(odd, a10))         # преобразуем генератор b8 в список
print("Класс - filter - list без цикла",type(b8), b8)             # <class 'list'> [1, 3, 5, 7, 9]

                                     # используем цикл - для перебора значений генератора
#for x in b8:                        # говорим что будем перебирать генератор b8
#    print(x, end=" ")               # выводим в консоль - значения в строку выводятся



                                    # используем lambda - функцию для перебора значений генератора вместо filter odd                                   
a11 = [1,2,3,4,5,6,7,8,9,10]
                                    # далее применим ф-цию lambda вместо filter
b9 = list(filter(lambda x: x%2, a11))    # указываем lambad с одним аргументом x,  затем что мы будем делать с аргументом
               # lambda x: not x%2  # все четные элементы
print("\nlambda - function", b9, type(b9))    # получили объект                


# Ф-цию filter можно использовать с разными типами данных
# Например с коллекцией, которая состоит из строк ("Москва", "Рязань1", "Смоленск", "Тверь2", "Томск")
# Из этого списка выберем слова из буквенных символов
lst5 = ("Москва", "Рязань1", "Смоленск", "Тверь2", "Томск")
b10 = list(filter(str.isalpha, lst5))   # В качестве аргумента у функции фильтр пропишем 
                                    # метод строки str.isalpha к списку lst5
print("\nИспользуем метод строки str.isalpha к списку lst5", b10, type(b10))    


# Ф-ция zip позволяет объединять между собой соответствующие элементы упорядоченных коллекций
# Предположим у нас имеется две коллекции (списка) - мы для них вызываем ф-цию zip
# На выходе получаем итератор
a12 = [1,2,3,4]
b11 = [5,6,7,8]

#b11 = [5,6,7]                      # при уменьшении списка до 3-х элентов на выходе кортеж из трех элементов

c2 = "abracadabra"                  # из этого списка берется только 4 элемента остальные отброшены

it = zip(a11, b11, c2)
print(it, type(it))
print("объединены в кортеж соответствующие элементы этих двух списков: ", list(it ) ) # Получим итератор, который возвращает следующую коллекцию [(1, 5), (2, 6), (3, 7), (4, 8)]
                                                                                      # преобразовали итератор к списку и вывели в консоль
# функция zip формирует выходной список, длина которого равна длине наименьшей из указанных коллекций                                                                                      # объединил соответствующие значения списков
                                                                                      # получили список из кортежей

