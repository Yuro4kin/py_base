# Словарь - это неупорядоченная коллекция произвольных данных с доступом по ключу
# Ключ - значение {key1: value1, key2: value2, …, keyN:valueN}
A = {"house": "дом", "car": "машина", "tree": "дерево", "road": "дорога", "river":"река"}
B = {"house": "дом", "house": "дом 2", "car": "машина"} # ключ уникален, но берется последнее значение
print(A, type(A))
print(B, type(B))

# Определить словарь  - функция-конструктор dict() - задать словарь
# ключи записываются без кавычек, после них ставится знак равно
C = dict(house = "дом", car = "машина", tree = "дерево", road = "дорога", river = "река")
# С = dict(house = "дом", 2 = "машина")  # не работают числовые значения, только для строк
print(C, type(C))


# Словари создаются на основании ранее сформированных данных, списков
# Список состоит из вложенных элементов - перечислены вложенные списки с двумя элементами: ключ, значение
D = [[2, "неудовлетворительно"], [3, "удовлетворительно"], [4, "хорошо"], [5, "отлично"]]
print(D, type(D))


# Преобразуем в словарь с помощью функции dict
listD = dict(D)
print(listD, type(listD))
# {2: 'неудовлетворительно', 3: 'удовлетворительно', 4: 'хорошо', 5: 'отлично'}



# dict.fromkeys(список[, значение по умолчанию])
# формирует словарь где ключами будут элементы списка
E = dict.fromkeys(["+7", "+6", "+5", "+4"], "код страны")
# {'+7': None, '+6': None, '+5': None, '+4': None}
# {'+7': 'код страны', '+6': 'код страны', '+5': 'код страны', '+4': 'код страны'}
print(E, type(E))

# Создать пустой словарь
F = {}
FF = dict()
print(F, FF)

# Любые неизменяемые типы данных можно указывать в словаре
# Присваивая словарю значение с новым ключом, оно автоматически добавляется в словарь
# Добавляем в словарь
# Если же мы существующему ключу присваиваем другое значение, то он просто поменяет свое значение в словаре
# Можем добавлять и менять значения словаря
# Словарь относится к изменяемым типам данных
F[True] = "Истина"
F[False] = "Ложь"
print(id(F), F)
F[True] = 1
print(id(F), F)

# если мы укажем изменяемый тип в качестве ключа - это недопустипо TypeError: unhashable type: 'list'
# F[[1, 2]] = 1


# ключи - используются строки или числа
# значения - произвольные данные
G = {True: 1, False: "Ложь", "list": [1,2,3], 5: 5}
#   key1:val1,key2: value2,   key3:  value3, key4:value4
print(G)

# удаление ключа - оператором del - по ключу
del G[True]
print(G)


# Проверка существует ли ключ в словаре
checkKey = "abc" in G
print(checkKey)

# Проверка несуществования ключа в словаре
checkKey1 = "abc" not in G
print(checkKey1)

# функция len - определить длину (число записей) в словаре
lenG = len(G)
print(lenG)


# Цикл for - перебор - выводит ключ и значение 
H = {True: 1, False: "Ложь", "list": [1,2,3], 5: 4}
for x in H:
    print(x)                         #  получится ключ - выводит ключ
    #print(x, H[x])                   #  получится и ключ и значение - выведет

# Очистить все записи из словаря
# H.clear()

# Создание копий словаря
dict1 = dict()
dict1 = {True: 1, False: "Ложь", "list": [1, 2, 3], 5: 5}
J = dict1.copy()

# Проверка по id - разные словари
print(id(dict1))               # Переменные ссылаются на разные объекты
print(id(J))                   # Переменные ссылаются на разные объекты
J["list"] = [5, 6, 7]          # Ключу list присвоим значение [5,6,7]
print(J)



# Метод get - возвращает значения по ключу словаря
getJ = J.get("list")
print(getJ)
# Аргумент False - если ключ неправильно указан, возвращает вместо None будет False
getJerror = J.get(3)
print(getJerror)
getJerror = J.get(3, False)
print(getJerror)


# dict.setdefault(key[, default]) - возвращает значение, ассоциированное с ключом key
# и если его нет, то добавляет в словарь со значением None,
# либо default – если оно указано
setJ = J.setdefault("list")
setJJ = J.setdefault(3)             # 3: None - несуществующий ключ добавляет в конец списка
print(J)
del J[3]                            # удалили 3: None
setJj = J.setdefault(3, 'three')    # 3: 'three' - добавил ключ и значение
print(J)



# d.pop - удаляет указанный ключ и возвращает его значение.
# Если в нем указывается несуществующий ключ, то возникает ошибка
J.pop(3)
popJ = J.pop("abc", False)          # в качестве второго аргумента указать значение, возвращаемое при отсутствии ключа
print(popJ)                         # что возвращать если такого ключа "abc" нет
popTrue = J.pop(True)               # ключ присутствует, то возвращается его значение 1
print(J, popTrue)



# d.popitem() - удаление произвольной записи из словаря
# Если словарь пуст, то возникает ошибка
K = {True: 1, False: "Ложь", "list": [1,2,3], 5: 5}
K.popitem()
print(K)


# метод d.keys() возвращает коллекцию, список ключей нашего словаря
# По умолчанию цикл for обходит именно эту коллекцию, при указании словаря:
L = {True: 2, False: "Ложь", "list": [4, 5, 6], 6: 6}
keysL = L.keys()
print(keysL)
for x in L:                        # выполняет перебор словаря по коллекции, работает анологично keys for x in L.keys():
    print(x, L[x])                 # переменная x принимает значение ключей
for x in L.values():
    print(x)                       # x будет перебирать не ключи а значения
for x in L.items():                # возвращает записи в виде кортежей
    print(x)
    print(x[0], x[1])              # Будет выводить ключ и значение по индексу элемента
                                   # или
for key, value in L.items():       # возвращает ключи и значения
    print(x)
    print(key, value)
