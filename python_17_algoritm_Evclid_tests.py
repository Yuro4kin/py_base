# алгоритм Евклида, принцип тестирования программ
# алгоритма Евклида для поиска наибольшего общего делителя (НОД)

# Пусть даны два натуральных числа a и b, для которых требуется найти НОД:

# пока a не равно b 
#         находим большее среди a и b 
#         уменьшаем большее на величину меньшего 
# выводим полученное равное значение преобразованных величин a и b

# операции несколько раз повторяются, пока истино это условие, в результате получим равные значения a и b
# которые будут являться НОД
# a = 18, b = 24 
# 18 24   (24 - 18 = 6)
# следующая итерация для чисел 18 и 6
# 18 6    (18 - 6 = 12)
# следующая итерация для чисел 12 и 6
# 12 6    (12 - 6 = 6)
# следующая итерация для чисел 6 и 6, они равны, поэтому условие - a не равно b - становится ложным, цикл завершается
# НОД(18, 24) = 6

import time                         # чтоб пользоваться модулем time, подключим его в начале программы

def getNOD(a, b):                   # ф-ция getNOD принимает два аргумента (числа) a, b
    """Вычисляется НОД для натуральных чисел a и b
        по алгоритму Евклида.
        Возвращает вычисленный результат НОД.

        пока a не равно b 
            находим большее среди a и b 
            уменьшаем большее на величину меньшего 
        выводим полученное равное значение преобразованных величин a и b
    """

    if a < b:                        
          a,b = b,a                   

    while b > 0:                    
          a,b = b, a%b                 

    return a                         

print( getNOD(45, 9) )

   # while a != b:                   # пока a неравно b 
   #     if a>b:                     # мы проверяем, если a > b, 
   #         a -= b                  # то в соответствии с алгоритмом a = а - b или a -= b, из большего а вычитаем b 
   #     else:
   #         b -=a                   # иначе если b > или равно = а, из b вычитаем a
                                     # условие становится ложным, возвращаем либо b, либо a, т.к. a и b будут равны между собой
                                     # теперь функция реализована
   # return a  
  
   #-- тест №3 - провален, поэтому модификация алгоритма  -----------------------------------#
   #     100000000 2                / 2 вычитается постоянно из 100000000, получается множество циклов
   #     4 - 2 = 2                  / такое вычитание будет на последнем шаге, после чего оба числа равные, НОД будет равен 2 
   #     100000000 % 2 = 0          / чтобы без лишних операций узнать насколько будут отличаться два числа после серии вычитаний, достаточно взять целый остаток от делений
   #                                / 0 говорит о том что большое число полностью может быть составлено из 2, следовательно они оба нацело делятся на 2, их НОД = 2
   #     100000000 % 3 = 1          / 1 полуим остаток, НОД для тих чисел равен 1
   #     3 % 1 = 1                  / при вычмслении остатка от деления, большее число делится на меньшее
   #     1 % 1 = 0

   #    Алгоритм Евклида
   #    пока меньшее число, т.е. остаток от деления больше 0, большее число делим на меньшее
   #    т.е. вычисляем остаток от деления большего на меньшее
   #    большему числу присваиваем остаток от деления на меньшее число
   #    выводим большее число

   #     переменная a - большее число,  b - меньшее число

   # if a < b:                        # если a < b мы должны поменять местами a и  b
   #    a,b = b,a                    # сделаем множественное присваивание

   # while b > 0:                     # цикл - пока b > 0, здесь a большее, b меньшее число
   #    a,b = b, a%b                 # используя присваивание, можем переменным присвоить нужный результат

   # return a                         # результат записываем в переменную а

   # print( getNOD(45, 9) )

                                    # проверяем, пока меньшше число больше 0, проверяем цикл
   #     t = b;                     # внутри цикла, временной переменной t присвоить значение b   // переменная t в которой сохранили b будет больше переменной b, в которой сохранили результат вычисления остатка   
   #     b = a % b                  # b присвоить результат значения деления a на b               // когда вычисляем остаток от деления a%b, он будет заведом меньше начальной величины b  
   #     a = t                      # переменной a присвоить значение переменной t

                                    # поэтому а присваиваем прежнее значение b переменной t, b - присваиваем остаток от деления
                                    # в этом алгоритме значение a будет всегда больше значения b
     

# Для проверки правильности рабты выполним тестирующую функцию

def testNOD():
    #-- тест №1 -----------------------------------#
    a = 28; b = 35
    res = getNOD(a, b)              # вычисляем значение с помощью функции getNOD
    if res == 7:                    # и мы знаем, что для чисел a, b результат должен быть равен 7
        print("#test1 - ok")        # т.е. мы проверяем, если результат равен 7, то проверка прошла, 
    else:
        print("#test1 - fail")      # иначе проверка не прошла

    #-- тест №2 -----------------------------------#
    a = 100; b = 1
    res = getNOD(a, b)              # вычисляем значение с помощью функции getNOD
    if res == 1:                    # и мы знаем, что для чисел a, b результат должен быть равен 7
        print("#test2 - ok")        # т.е. мы проверяем, если результат равен 7, то проверка прошла, 
    else:
        print("#test2 - fail")      # иначе проверка не прошла

    #-- тест №3 -----------------------------------#
    a = 2; b = 100000000

    st = time.time()                # вычислим скорость работы алгоритма, время его работы, засекаем начальное время
    res = getNOD(a, b)              # вычисляем значение с помощью функции getNOD
    et = time.time()                # засекаем конечное время
    dt = et - st                    # вычисляем разность между начальным и конечным временем (получили время работы алгоритма)

    if res == 2 and dt < 1:         # если результат алгоритма будет равен 2 и время работы меньше 1 секунды, то тест пройден
        print("#test3 - ok")        # т.е. мы проверяем, если результат равен 7, то проверка прошла, 
    else:
        print("#test3 - fail")      # иначе проверка не прошла

testNOD()                           # вызвали тест в конце программы        

# главная задача теста - обеспечить гаранти роботопособности программы
