# Итераторы, выражения-генераторы, функции-генераторы, оператор yield

a = [x**2 for x in range(10)]            # генератор списков
                                         # создается список состоящий из квадратов чисел от 0 до 9
print("Значения списка а: ", a)

# выражения-генераторы похожи на генератор списка - вместо [] скобок () круглые
b = (x**2 for x in range(10))            # <generator object <genexpr> at 0x000001B4DE186900>

# Генератор – это итератор, элементы которого можно перебирать
# (итерировать) только один раз.

# Итератор – это объект, который поддерживает функцию next()
# для перехода к следующему элементу коллекции.

# Итерируемый объект – это объект, который позволяет поочередно обойти
# свои элементы и может быть преобразован к итератору.

# Самый распространенный итерируемый объект в Python – это список
a1 = [1,2,3]
# чтобобойти элементы списка используем цикл for, или обратимся к элемену по его индексу

# Перебор списка с помощью ИТЕРАТОРА
# преобразуем список к объекту итератора - функция iter()
it = iter(a1)                                  # ф-ция iter
print("Значения списка а1: ", a1, it)          # <list_iterator object at 0x0000021D51667D60>
                                               # в консоль вывели и увидели что это итератор списка                                            
# Применим и вызовем функцию next() для перехода к следующему элементу коллекции
print("Функция next() возвратила первый элемент коллекции a1: ", next(it))
print("Функция next() возвратила второй элемент коллекции a1: ", next(it))
print("Функция next() возвратила третий элемент коллекции a1: ", next(it))
# На коллекцию a1 ссылается итератор it и через него перебираем элементы, используя функцию next()
# Из списка a1 получили итератор, с его помощью перебрали коллекцию, но только один раз

# Дойдя до конца списка, итератор it не может вернуться в начало и перебрать
# список еще раз. Этот проход по элементам делается только один раз.

# выражение-генератор, переменную b1 можно принимать как итератор
# и перебирать список через функцию next()
b1 = (x**2 for x in range(10))
print("Функция next() возвратила первое значение выражения-генератор коллекции b1: ", next(b1))
# b1 - это генератор – т.е. итератор, элементы которого можно перебирать с помощью функции next()
# мы можем получать итератор для любого итерируемого объекта или создавать его с помощью выражения генератора  b1 = (x**2 for x in range(10))

# Преимущества данных объектов перед списками
# - не хранят в памяти сразу все значения
# - генерируют их по мере необходимости, т.е. при переходе к следующему значению
# - при попытке создания списка длины 1000000000000 - в Python нехватает памяти 
# - lst = list(range(1000000000000))
lst = (x for x in range(1000000000000))         # генератор выражения может перебирать такой список / задали генератор списка
for i in lst:                                   # будем перебирать последовательно
    print(i, end=" ")                           # в консоль вывели текущее значение для генератора
    if i > 100: break                           # когда i превысит значение 100, прервем этот цикл, т.к. делаться будет очень долго
                                                # генератор сгенерировал значения и остановился когда i превысило значение 100
                                                # когда необходиомо перебрать огромные значения можем использовать генератор
                                                # ПОМНИ - цикл делается один раз для одного определенного генератора

print("\nnew loop ")                            # попробуем повторить этот цикл

for i in lst:                                   # будем перебирать последовательно
    print(i, end=" ")                           # в консоль вывели текущее значение для генератора
    if i > 200: break                           # когда i превысит значение 200, прервем этот цикл
                                                # второй цикл пошел со значением 102, мы в начало не переходим
                                                # ПОМНИ - выражение генератор проходит по списку только один раз

# Функции - sum, max, min - позволяют работать с выражениями генераторами                                                

# посчитаем сумму квадратов всех чисел
b2 = (x**2 for x in range(10))
print("\nСумма квадратов всех чисел выражения b2: ", sum(b2))
# посчитаем max значение в последовательности чисел выражения b3
b3 = (x**2 for x in range(10))
print("Максимальное значение в последовательности чисел выражения b3: ", max(b3))

# Выражения генераторы не хранят в памяти всех значений
# Функция - len() воспользоваться не можем
# b3[2] - не можем получить доступ к отдельному элементу
# для перебора значений используем for или нужно преобразовать выражение генератор к списку, затем его перебрать

# Преобразование выражения генератора к списку и его дальнейший перебор
b4 = (x**2 for x in range(10))                  # выражение генератор
b4list = list(b4)                               # с помощью ф-ции list() преобразовали выражение генератор к списку
                                                # список будет состоять из этих значений
print("Преобразовали выражение генератор b4 к списку : ", b4list)
print("Проверка - выражение генератор b4 это список : ", type(b4list))
print("Обратились к элементу по определенному индексу в выражении генераторе b4 : ", b4list[4])

# Функции генераторы, оператор yield

# Функция для вычисления средних арифметических для каждой из сумм
# для одного значения, для двух, для трех и т.д.
# Обычную функцию переписываем в функцию - генератор
# в результате нам не нужен список для хранения всех значений, а значит мы экономим память
def getAllAverage(N):
    avs = []                                   # этот список уже не нужен
    count = 0
    S = 0
    for i in range(1,N+1):
        count += 1
        S += i
#        avs.append( S/count )                 # этот список уже не нужен
 
    # return avs                               # уберем оператор return и вместо него запишем оператор yield
        yield S/count                          # укажем операторы yield возвращаемое значение

itFunc = getAllAverage(10)                     # для вызова функции генератора создадим итератор
print( next(itFunc) )                          # с помощью функции next() будем перебирать значение итератора
print( next(itFunc) )
print( next(itFunc) )
print( next(itFunc) )
print( next(itFunc) )
print( getAllAverage(100) )                    # вызвали функцию со значением 100 
print("Размер памяти в byte: ", getAllAverage(100).__sizeof__() )        # размер памяти в byte был :  904  стал :96

# если N увеличить в десятки раз, мы получим список, занимающий мегабайты памяти компьютера!
# оптимизируем этот процесс по размеру занимаемой памяти, в Python предусмотрены так называемые функции-генераторы

# Простая функция-генератор для примера
# Есть функция которая возвращает список от 0 до 9
def f():
    return list(range(10))
print( f() )

# Превратим эту функцию в функцию генератор
def fgen():
    for x in range(10):                         # цикл for, x будет перебирать диапазон range  до 10
        yield x                                 # тело цикла - оператор yield возвращает значение x и
                                                # замораживает текущее состояние функции, т.е. при
                                                # повторном вызове ф-ции, цикл for начнется не с начала,
                                                # а с той итерации на которой был заморожен, т.е. перейдет к следующему значению x,
                                                # оператор yield возвратит следующее значение

sgen = fgen()                                   # для вызова ф-ции генератора сохраним ее текущее состояние в переменной sgen
print("Выведем переменную sgen и ее тип в консоль : ", sgen, type(sgen))      # выведем переменную sgen консоль

# Раз это генератор, то мы можем выводить его значение с помощью функции next
# next для перебора значений, которые будет возвращать функция
print( next(sgen) )                             # когда мы вызываем next(), то мы получали новое значение переменной x
print( next(sgen) )                             # получаем все преимущества использования генераторов, экономию занимаемой памяти
print( next(sgen) )
