import pickle                  # для работы с бинарными данными подключим специальный встроенный модуль pickle
                               # через методы этого модуля будем работать с бинарными данными

# считывать информацию из файлов и записывать ее в файлы

# Функция через которую осуществляется работа с файлами
# open(file [, mode=’r’, encoding=None, …])
#      file – это путь к файлу вместе с его именем;
#              mode – режим доступа к файлу;
#                        encoding – кодировка файла.

# Чтобы обратиться к файлу my_file.txt путь можно записать так:
# "my_file.txt"                 # относительный путь, относительно рабочего каталога
# или
# "d:\\app\\my_file.txt"        # абсолютный путь к файлу, то есть, полный путь, начиная с указания диска
# или так:
# "d:/app/my_file.txt"          # абсолютный путь к файлу, то есть, полный путь, начиная с указания диска

# Чтоб обратиться к файлу img.txt. Это можно сделать так:
# "images/img.txt"              # относительный путь, относительно рабочего каталога
# или так:
# "d:/app/images/img.txt"       # абсолютный путь к файлу, то есть, полный путь, начиная с указания диска
# Для доступа к out.txt пути будут записаны так:
# "../out.txt"
# "d:/out.txt"

# для доступа к файлу prt.dat пути запишутся так:
# "../parent/prt.dat"           # вышли на уровень вверх -  относительный путь, относительно рабочего каталога
# "d:/ parent/prt.dat"          # абсолютный путь к файлу, то есть, полный путь, начиная с указания диска

# Воспользуемся функцией open и укажем у нее один аргумент
try:                            # запишем критический код в блоке try 
    # file = open("myfile.txt", encoding = "utf-8")
    file = open("myfile.txt")   # Если ничего не указываем это читать
                                # изменение кодировки для чтения данных из файла
                                # UTF-8 - каждый символ представляется 2 байтами, сместились на 3 байта
                                # Изменим кодировку нашего файла на windows 1251 ANSI - возникнет ошибка, указали неверную кодировку
                                # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc2 in position 0
                                # windows 1251 ANSI - каждый символ представлен представлен одним байтом
                                # так вычисляется позиция внутри файла


                                
    #file = open("out.txt", "w")# Если w - вторым аргументом - это записывать.
                                # Функции open говорим вторым параметром, что мы будем делать с файлом

    print( file.read(2) )       # file.read - читает все содержимое нашего файла
                                # file.read(2) - читает из файла первые два символа

    file.seek(0)                # прочитаем первые наши два символа, затем сместим файловую позицию на начало и опять читаем два типа             

    print( file.read(2) )       # читает еще два символа из файла
                                # file position - показывает с какого места мы будем производить считывание информации 

    pos = file.tell()           # метод tell для получения файловой позиции - возращает номер файловой позиции                    
    print( pos )                # выводим в консоль
                                # аша кодировка UTF-8, а позиция определяется в байтах
                                # Сместились на 3 байта
    
                                
                                # ф-ция print выводит то что мы прочитали в консоль
                                # ф-ция read возвратила прочитанную строку
# Если указать неверный путь, например, так:
# file = open("myfile1.txt")    - то возникнет ошибка FileNotFoundError, обработав ее через try получим сообщение
                                # "Невозможно открыть файл"
except FileNotFoundError:
    print("Невозможно открыть файл")

# Ф-ция open по умолчанию открывает файл в текстовом режиме на чтение - mode = "r"
# Ф-ция open открывает файл на запись - mode = "w" - вторым аргументом
# file = open("out.txt")        # Если ничего не указываем это читать
# file = open("out.txt", "w")   # Если w - вторым аргументом - это записывать


# В Python имеются следующие режимы доступа:
# Название    -     Описание
# 'r' - открытие на чтение (значение по умолчанию)
# 'w' - открытие на запись (содержимое файла удаляется, а если его нет, то создается новый)
# 'x' - открытие файла на запись, если его нет генерирует исключение
# 'a' - открытие на дозапись (информация добавляется в конец файла)
# Дополнения
# 'b' - открытие в бинарном режиме доступа к информации файла
# 't' - открытие в текстовом режиме доступа (если явно не указывается, то используется по умолчанию)
# '+' - открытие на чтение и запись одновременно

# Мы имеем три основных режима доступа: на чтение, запись и добавление.
# И еще три возможных расширения этих режимов:
# 'rt' – чтение в текстовом режиме;
# 'wb' – запись в бинарном режиме;
# 'a+' – дозапись или чтение данных из файла.

# Откроем файл в текстовом режиме и прочитаем его содержимое с помощью метода - read()
#print( file.read() )           # file.read - читает все содержимое нашего файла
                                # ф-ция print выводит то что мы прочитали в консоль

# Управление файловой позицией с помощью метода
# seek(offset[, from_what])     - метод seek показывает на сколько мы можем сместить file position относительно начала файла                           


# Метод .readline() - позволяет построчно считывать информацию с текстового файла
# концом строки считается символ переноса ‘\n’ на следующую строку, либо конец файла
try:                            # запишем критический код в блоке try 
    file1 = open("myfile1.txt")
                                  # _1_
#   s1 = file1.readline()
#   print( s1 )
#   print( file1.readline() )     # добавим чтение еще одной строчки
                                  # получается пустая строка - символ переноса от самой функции print

                                        # _2_
#   print( file1.readline(), end = "" ) # переписали и убрали символ переноса у функции print - то пустых строк у нас уже не будет
#   print( file1.readline(), end = "" ) # переписали и убрали символ переноса у функции print - то пустых строк у нас уже не будет

                                   # _3_
                                   # последовательно прочитать все строчки из файла используем цикл for
#    for line in file1:            # пишется сам цикл, потом переменная, далее говорим что будем перебираь итерируемый объект файл
#         print( line, end = "")   # в теле цикла for выведем переменную line - все наши строчки последовательно считаны
                                   # объект file1 является итерируемым - на каждой итерации возвращает очередную строку из файла

                                  # _4_
                                  # сразу прочитать все строки - метод .readlines()
    try:                          # чтобы программа дошла точно до .close() - чтобы мы точно закрыли файл        
      s2 = file1.readlines()
      print(s2)                   # получаем список из соответствующих строк с символом переноса на новую строку
                                  # для больших файлов может возникнуть ошибка нехватки памяти для хранения полученного списка
                                  # обычно информация из файла читается построчно

    finally:
                                  # метод .close() - закрытия файла
      file1.close()               # закрывая файл мы освобождаем память связанную с этим файлом
                                  # не будет проблем в потере данных при их записи в файл
                                  # метод .close() - гарантировано записывает все наши данные в файл
                                  # данные записываются через буфер, а буфер находится в памяти, если файл не закрыть часть данных может остаться
                                  # метод .close() - всегда используем, читаем или записываем

except FileNotFoundError:
    print("Невозможно открыть файл")


# Для открытия файла используют мейжер контекста - когда файл открывают при помощи оператора with


try:

    with open("myfile.txt", "r") as file:      # эквивалентная строка - file = open("myfile.txt")
        s = file.readlines()                   # критичный код
        print( s )                             # мейжер контекста - автоматически закрывает файл
                                               # после того как конструкция входящая в этот мейжер
        
#       print( int(s) )                        # преобразуем строку в число - и узнаем будет ли автоматически закрываться файл
                                               # True - несмотря на ошибки в блоке, файл гарантировано закрывается
 
except FileNotFoundError:
    print("Невозможно открыть файл")

finally:
    print(file.closed)                         # проверка мейжера контекста - сигнализирует что файл закрыт
                                               # Флаг closed равен True - файл автоматически закрылся

# Запись информации в файл                                               
# Во-первых, нам нужно открыть файл на запись, например, так:
try:
    file = open("out.txt", "w")                # записываем данные в текстовом режиме доступа
                         # "wt"                # когда мы открываем файл на запись в режимах - w, wt, wb
                         # "wb"                # когда открываем файл в режимах - w, wt, wb - прежнее содержимое удалено и добавлено новое
                         # "a"                 # добавить еще три строчки Hello1
                         # "a+"                # можем и дозаписывать информацию и считывать

    try:                                       # Что будет если метод .write() вызовем несколько раз подряд
        file.write("Hello1\n")                 # "Hello" прежнее содержимое удалено и добавлено новое
        file.write("Hello2\n")                 # Все происходит как и со считыванием, объект файл - записывает информацию, начиная с текущей файловой позиции 
        file.write("Hello3\n")                 # И автоматически перемещает ее при методе write
                                               # \n - перевод, все наши строчки записаны с новой строки

        file.writelines(["Hello4\n", "Hello5\n"])  # .writelines() - метод для записи информации в файл
                                                   # позволяет записывать несколько строк сразу в файл
                                                   # строки представлены в виде списка
                                                   # можно записывать и считывать информацию из текстовых файлов

                                               # _1_
#       file.seek(0)                           # можем и дозаписывать информацию и считывать "a+"
#       print(file.read())                     # Error - Мы не можем читать когда файл открыт на запись
        
    finally:
        file.close()

except FileNotFoundError:
    print("Невозможно открыть файл")



# Бинарный режим доступа - данные из файла считываются один в один без какой-либо обработки.
# Обычно это используется для сохранения и считывания объектов.
# Предположим, что есть объект и нужно сохранить в файл такой список:
books = [
   ("Евгений Онегин", "Пушкин А.С.", 200),
   ("Муму", "Тургенев И.С.", 250),
   ("Мастер и Маргарита", "Булгаков М.А.", 500),
   ("Мертвые души", "Гоголь Н.В.", 190)
]

try:
   file3 = open("out.bin", "rb")                   # Откроем файл с расширением .bin - с режимом доступа wb, на запись в бинарном режиме
                         # "wb"  - режим доступа
                         # "rb"  - если мы хотим прочитать информацию из файла и поместить в объект
   try:
#      pickle.dump(books, file3)                   # Для записи в файл используется метод dump (указываем что записываем - books, куда записываем - file)
                                                   # передаем ссылку на открытый файл "wb"
                                                   # появляется файл out.bin - будет абракадабра, что в памяти представляется, то перенесли в файл
                                                   

                                                   # если мы хотим прочитать информацию из файла и поместить в объект
                                                   # укажем режим доступа "rb"
       bs = pickle.load(file3)                     # вместо метода dump используем метод .load() - на выходе этот метод формирует объект, который считывается из этого бинарного файла
                                                   # ссылка на этот объект bs =
       print( bs )                                 # выведем переменную bs в консоль - прочитали объект, который туда и записывали
   finally:
       file3.close()

except FileNotFoundError:
    print("Невозможно открыть файл")


# Аналогичным образом можно записывать и считывать сразу несколько объектов   
# Все их запишем в наш файл

# Запись

book1 = ["Евгений Онегин", "Пушкин А.С.", 200]
book2 = ["Муму", "Тургенев И.С.", 250]
book3 = ["Мастер и Маргарита", "Булгаков М.А.", 500]
book4 = ["Мертвые души", "Гоголь Н.В.", 190]
 
try:
    file = open("out1.bin", "wb")                   # "wb" - бинарный режим доступа для записи
 
    try:
        pickle.dump(book1, file)                    # четыре раза вызовем метод dump - укажем какие объекты туда сохраняем
        pickle.dump(book2, file)                    # се объекты друг за другом будут помещены в файл
        pickle.dump(book3, file)
        pickle.dump(book4, file)
 
    finally:
        file.close()
 
except FileNotFoundError:
    print("Невозможно открыть файл")



# Чтение

try:
   file = open("out1.bin", "rb")                   # Откроем файл с расширением .bin - с режимом доступа wb, на запись в бинарном режиме
                         # "wb"  - режим доступа
                         # "rb"  - если мы хотим прочитать информацию из файла и поместить в объект
   try:
                                                   # если мы хотим прочитать информацию из файла и поместить в объект
                                                   # укажем режим доступа "rb"
       b1 = pickle.load(file)                      # вместо метода dump используем метод .load() - на выходе этот метод формирует объект, который считывается из этого бинарного файла
       b2 = pickle.load(file)                      # ссылка на этот объект bs =
       b3 = pickle.load(file)
       b4 = pickle.load(file)
       print( b1, b2, b3, b4, sep="\n" )           # выведем переменную bs в консоль - прочитали объект, который туда и записывали
   finally:
       file.close()

except FileNotFoundError:
    print("Невозможно открыть файл")
