# Для обработки строк с помощью регулярных выражений
import re

# Выделим из строки map
text = "Карта map и объект bitmap - то разные вещи"

# говорим что будем искать, фрагмент map, где искать - в text
match = re.findall("map", text)
print(match)
# ['map', 'map'] - нашел оба вхождения


# Теперь задача найти map, что является целым словом  
text_1 = "Карта map и объект bitmap - то разные вещи"

# Определим соответствующий шаблон
# Если мы ставим один r перед шаблоном, можем использовать один \
# Можно с легкостью обрабатывать самые разные строки
match_1 = re.findall(r"\bmap\b", text_1)
print(match_1)
# ['map']


text_2 = "еда, беда, победа"
match_2 = re.findall(r"еда", text_2)
print(match_2)
#['еда', 'еда', 'еда']
# алгоритм сначала находит e, затем д, затем а, условие выполнено

# Однако, не все символы можно записывать в явном виде.
# Есть специальные символы, которые относятся к языку регулярных
# выражений. Они следующие:
#                               \.^$?+*{}[]()|

# проверка "(еда)" - #['еда', 'еда', 'еда']
# проверка r"\(еда\)" - text_2 = "(еда), беда, победа" - ['(еда)']

# \n - символ перевода строки, \t - символ табуляции

# Символьные классы
# Часто требуется найти не одно какое-то конкретное написание слова,
# а все его множественные формы, например:
#   city, cities, City, Cities
text_3 = 'city, cities, City, Cities'
match_3 = re.findall(r"[cC]it[yi]", text_3)
print(match_3)

text_4 = 'city, cities, 5 55 City, Cities'
match_4 = re.findall(r"[0123456789]", text_4)
# это выражение описывает только один символ
print(match_4)
# поиск двух цифр подряд, одну цифру уже не найдем
match_5 = re.findall(r"[0123456789][0123456789]", text_4)
print(match_5)
# так записывать неудобно, поэтому шаблон записываем цифры интервалом
match_6 = re.findall(r"[0-9][0-9]", text_4)
print(match_6)

# поиск и дефиса и цифр
text_5 = 'city, cities, -6 66 City, Cities'
match_7 = re.findall(r"[-0-9][0-9]", text_5)
# дефис найдется, затем цифра 6, и комбинация будет выведена
print(match_7)

# Инвертируем шаблон символьного класса
text_6 = 'city, cities, -7 77 City, Cities'
match_8 = re.findall(r"[^0-9]", text_6)
# ищем не цифры 7, комбинация будет выведена, в шаблон попадают все символы
# которые не относятся к цифрам
print(match_8)

# Перебор букв малых и больших, и цифр
match_9 = re.findall(r"[a-zA-Z0-9]", text_6)
print(match_9)


# Специальные символы воспринимаются как обычные отдельные символы
#               .^$?+*{}[]()|  - так они и воспринимаются в шаблоне, кроме
#           \ - обратный слеш функционал не теряет



# Некоторые наборы символов, например, [0-9] или [^0-9] и другие
# довольно часто используются на практике, поэтому им были назначены
# специальные краткие формы:

# Символ    -   Значение

# .             Соответствует любому символу, кроме символа переноса строки (‘\n’).
#               Но, если установлен флаг re.DOTALL, то точка соответствует вообще любому символу в тексте.
#               Однако, если она записана внутри символьного класса [.], то воспринимается как символ точки.

# \d            Соответствует любой цифре, если используется кодировка Юникода.
#               Если же установлен флаг re.ASCII, то диапазону цифр [0-9].

# \D            Соответствует любому не цифровому символу для Юникода или символьному классу [^0-9] при установленном флаге re.ASCII

# \s            Для Юникода – любой пробельный символ. Для re.ASCII – символьному классу [ \t\n\r\f\v]

# \S            Для Юникода – любой не пробельный символ. Для re.ASCII – символьному классу [^ \t\n\r\f\v]

# \w            Для Юникода – любой символ слова. При флаге re.ASCII – набору символов [a-zA-Z0-9_]

# \W            Для Юникода – любой не символ слова. При флаге re.ASCII – набору символов [^a-zA-Z0-9_]


#                        \d - все цифры
#                         . - любой символ, кроме переноса строки
#                         \w - имволы слова и цифровые
match_10 = re.findall(r"\w", text_6)
# при флаге, который записывается  ,re.ASCII  3-им аргументом
# флаги влияют на работу регулярных выражений
print(match_10)





text_7 = "0xf, 0xa, 0x5"
#           Задание:    \d\w 
match_11 = re.findall(r"0x[\da-fA-F]", text_7)
# Шаблон - сначала 0, потом буква x, затем определяем символный класс,
# \d - может идти любая цифра,  затем любая буква от a до f, от A до F
# Стандартные наборы можем использовать и внутри символьного класса, кроме .
# . Точка соответствует если стоит внутри регулярного выражения r".[]", а не символьного класса
# Если точка стоит внутри символьного класса r"[.]" то выполняет работу обычного символа точки.
print(match_11)
