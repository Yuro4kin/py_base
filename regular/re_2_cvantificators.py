import re

# Регулярные выражения #2: квантификаторы {m,n}, +, * , ?
# где m – минимальное число совпадений с выражением;
# n – максимальное число совпадений с выражением.

text = "Google, Gooogle, Goooooogle"
match = re.findall(r"o{2,5}", text)
#                   ['oo', 'ooo', 'ooooo']
# символ o может повторяться от 2 до 5 раз, данная комбинация соответствует шаблону
# квантификаторы находят наиболее длительные последовательности
# жадный квантификатор
print(match)

# минорный квантификатор ? - ищет последовательности минимальной длинны
# ['oo', 'oo', 'oo', 'oo', 'oo']
match_1 = re.findall(r"o{2,5}?", text)
print(match_1)

# Краткие формы записи:
# {m} – повторение выражения ровно m раз (эквивалент {m,m});
# {m,} – повторения от m и более раз;
# {, n} – повторения не более n раз.
# или
# минорный режим {m,}?    {,n}?

# Будем выделять слово Google, где oo от двух и более
match_2 = re.findall(r"Go{2,}gle", text)
print(match_2)
# ['Google', 'Gooogle', 'Goooooogle']

# Будем выделять слово Google, где oo не более четырех
match_3 = re.findall(r"Go{,4}gle", text)
print(match_3)
# ['Google', 'Gooogle']

# Определим правильность записи номера телефона - первая 8, затем идет цифра \d 10 раз
phone = "89123456789"
match_4 = re.findall(r"8\d{10}", phone)
print(match_4)
# ['89123456789'], если убираем одну цифру строка не соответствует шаблону []
# Так можем проверять и находить корректные телефоны в наших строках


# Для квантификаторов {0,} и {1,} существуют специальные символы:
# {0,} - взять 0 повторений и до бесконечности = *
# {1,} - взять 1 повторение и до бесконечности = +
# ? – от нуля до одного (аналог {0,1});
# * – от нуля и до «бесконечности» (в действительности, большого числа – от 32767), соответствует квантификатору {0,};
# + – от единицы и до «бесконечности» (также большого числа – от 32767), соответствует квантификатору {1,}.
# Все эти сокращения также можно использовать в минорном режиме:
#       ??    *?    +?

# Квантификатор ?
text_1 = "Maybelline, Maybeline"
match_5 = re.findall(r"Maybell?ine", text_1)
# Комбинация l? говорит нам, что буква l не обязательна. Может повторяться от 0 до 1. Может быть, может не быть.
# ['Maybelline', 'Maybeline'] - оба слова были найдены
print(match_5)


# Парсинг - сделаем разбор этой строки по ключам и значениям 
text_2 = "author=Пушкин А.С.; title = Евгений Онегин; price =200; year= 2001"
match_6 = re.findall(r"\w+\s*=\s*[^;]+", text_2)
# \w - соответствует символам слова, далее квантификатор +
# + - квантификатор от единицы и до «бесконечности»
# \s - перед знаком = могут быть пробелы, * от 0 и более
# после знака = тоже могут быть пробелы от 0 и более
# выделяем все слова кроме ;
# [^;] - используем символьный класс, который инвертирует символ;
# учитываем все символы кроме ; + переберем эти символы от 1 и более 
print(match_6)
# Выделим ключ и значение, до ; все пары ключ=значение выделены
# ['author=Пушкин А.С.', 'title = Евгений Онегин', 'price =200', 'year= 2001']

# Упрощенная форма
d = text_2.split(";")
print("split(';')", d)


# Сразу выделим и ключ и значение по отдельности,
# получим кортежи состоящие из ключа и значения
match_7 = re.findall(r"(\w+)\s*=\s*([^;]+)", text_2)
print(match_7)
# [('author', 'Пушкин А.С.'), ('title', 'Евгений Онегин'), ('price', '200'), ('year', '2001')]


# Рассмотрим примеры минорных квантификаторов.
# Часто это бывает необходимо при разборе HTML-документа.
# Например, у нас имеется следующий текст, нам нужно выделить фрагмент с
# тегом  <img src='bg.jpg'>
text_3 = "Картинка <img src='bg.jpg'> в тексте</p>"
match_8 = re.findall(r"<img.*>", text_3)
print(match_8)
# ["<img src='bg.jpg'> в тексте</p>"] - пойдет дальше за тег <img>...
# шаблон .* определяется так - после img взять любой символ от 0 до бесконечности
# пока не встретится угловая скобка, т.к. квантификатор .* жадный
# поиск выполняется в наиболее длительной последовательности

# выполним поиск через минорный квантификатор ? - берем короткую последовательность
match_9 = re.findall(r"<img.*?>", text_3)
print(match_9)
# ["<img src='bg.jpg'>"]

# выполним поиск через символьный класс, не содержащий угловую скобку:
# будет перебирать символы которые не соответствуют гловой скобке >
# как только встречается > последовательность перебора завершается
match_10 = re.findall(r"<img[^>]*>", text_3)
print(match_10)

# Умение составлять короткие и понятные шаблоны – это часть
# искусства программирования.
# Улучшим наше выражение, чтобы оно учитывало атрибут src='bg.jpg'
match_11 = re.findall(r"<img\s+[^>]*?src\s*=\s*[^>]*>", text_3)
print(match_11)
# Мы здесь берем начало тега <img, затем, обязательно должен идти
# один или несколько пробелов \s, далее, могут быть записаны другие
# атрибуты +, потом указываем, что должен быть квантификатор
# т.к. может идти атрибут alt атрибут src,
# [^>] - квантификатор будет перебирать все остальное, пока не встретит символ src
# [^>]* - квантификатор должен работать в минорном режиме, не должен
# брать максимальную последовательность, а должен взять минимальную,
# пока не встретит три буквы src
# за которым следует символ = и пробелы могут быть по разному записаны
# учтем пробелы символьным классом \s, и поставим *, пробелы могут быть,
#  могут и не быть, далее = и тоже самое \s*
# после возьмем все символы до конца, кроме угловой скобки [^>], т.к.
# их может быть несколько поставим квантификатор + 

# Поиск с атрибутом alt     [^>]*? - квантификатор перебирает все символы                             
text_4 = "Картинка <img alt='картинка' src='bg.jpg'> в тексте</p>"
match_12 = re.findall(r"<img\s+[^>]*?src\s*=\s*[^>]*>", text_4)                             
print(match_12)

