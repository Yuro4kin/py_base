# декораторы функций и замыкания

# Декоратор в Python – это функция, которая в качестве аргумента принимает
# другую функцию и расширяет ее функционал без изменения последней

# Пример, как определяются и используются декораторы

import time         # подключим модуль time, чтоб его использовать

# Алгоритм Евклида для поиска НОД двух натуральных чисел a и b
def getNOD(a, b):
    while a != b:
        if a > b: a-= b
        else: b -= a
    return a

# Создадим тест для проверки скорости работы этой функции
# Реализуем этот тест в виде декоратора

def testTime(fn):                       # название функции  testTime
                                        # - в качестве аргумента принимает ссылку на ф-цию fn, у нас это getNOD
    def wrapper(*args):                 # внутри ф-ции запишем обвертку (функцию) wrapper - и в ней вычислим время работы fn
        st = time.time()                # замеряем время работы ф-ции - // это расширяем функционал
        fn(*args)                       # вызываем функцию fn
        dt = time.time() - st           # веведем в консоль dt        - // это расширяем функционал
        print(f"Время работы ф-ции: {dt} сек")
    return wrapper                      # ф-ция testTime будет возвращать обвертку wrapper и можем ее вызывать
                                        # обвертка (функция) wrapper - расширяет функционал ф-ции fn




test1 = testTime (getNOD)
# Передаем в testTime() ссылку на ф-цию getNOD
# Когда вызываем ф-цию testTime с аргументом (getNOD):
#    
#       - testTime(fn)
#               wrapper(*args)
#               fn(*args)
#
#       - return wrapper
#
# testTime(fn) возвращает wrapper,
# переменная test1 будет ссылаться на wrapper, т.е. на обвертку
# 
# Затем используя test1 мы можем вызывать обвертку (функцию) wrapper
# Т.к. обвертка расширяет функционал ф-ции fn, то мы через декоратор дополним вызов нашей ф-ции
# измерением скорости ее работы

# Достоинства - имеем возможность создать новое имя test1 для ф-ции
# чтоб в дальнейшем работать с ф-цией через второе имя test1
# подразумевая что расширяем работу ф-ции getNOD

# вызовем ф-цию wrapper через test1 и передадим два аргумента 100000, 2
# аргумент будет передан в wrapper(*args) и ф-ция fn с двумя аргументами будет вызвана fn(*args)
# будем вызывать getNOD(a, b) с этими двумя аргументами
# Получим время работы ф-ции
test1(100000, 2)


# Написание ф-ции testTime без обвертки wrapper
#                  
#def testTime(fn, *args):
#                  ^
#               аргументы *args    - и убираем def wrapper(*args):
#        st = time.time()
#        fn(*args)
#        dt = time.time() - st
#        print(f"Время работы: {dt} сек")
#
# Вызов будет таким с двумя аргументами:
#testTime (getNOD, 100000, 2)

# Недостатки - когда будем вызывать обвертку testTime - всегда будем указывать ф-цию getNOD
# в качестве первого аргумента fn

# ВНИМАНИЕ! Ф-ция wrapper использует аргумент fn в внешней ф-ции testTime
# при таком вызове test1 = testTime (getNOD) в программе создается два объекта ф-ции: testTime и wrapper

#
#               wrapper(*args):         testTime(fn)
#   test1 -- >  ...             -->     ...             --> Global
#               fn(*args)        ^       fn = getNOD
#               ...             ссылка
#                          объект-testTime
#                       не удаляется сборщиком мусора
#                       существует, пока сущ. ф-ция wrapper

# Графическое представление - идет вызов test1 = testTime (getNOD), в результате
# у нас здесь создаются два объекта-функции: testTime и wrapper.
# test1 ссылается на внутреннюю ф-цию wrapper = на wrapper ссылается глобальная переменная test1,
# а сам wrapper содержит ссылку на внешний контекст, т.е.
# на содержимое функции testTime, откуда и берет переменную fn.
# Благодаря наличию этой ссылки объект testTime не удаляется сборщиком мусора и продолжает существовать,
# пока существует wrapper. Это в программировании называется замыканием, т.е.
# когда вложенная функция ссылается на контекст внешней функции и потому имеет возможность обращаться
# ко всем локальным переменным этого внешнего контекста.

#  Декоратор, вызовем его для быстрого алгоритма Евклида
def getFastNOD(a, b):
    if a < b: a,b = b,a
    while b: a,b = b, a%b
    return a

test2 = testTime(getNOD)
test3 = testTime(getFastNOD)        # вызовем обертку testTime ля быстрого алгоритма
                                    # обертка выдает время работы ф-ции
 
test2(100000, 2)
test3(100000, 2)

# функцию wrapper можно записать в еще более универсальном виде,
# добавив необязательный список возможных именованных параметров
#
# def wrapper(*args, **kwargs):         # если они есть будут сюда передаваться
# ...
#     fn(*args, **kwargs)               # если их нет, сюда не будут передаваться
#
# благодаря передаче аргументов можем тестировать на скорость работы любые ф-ции

# Если записать ф-цию testTime в ссамом верху программы, и чтоб применить декоратор к нужной ф-ции
# пишем - @testTime - перед нужной ф-цией в программе
# Нужная ф-ция как-бы оборачивается в этот декоратор,
# автоматически аргументу fn передаем ссылку на ф-цию getNOD
# При таком вызове вызывается не сама ф-ция getNOD а декоратор testTime

def testTime_1(fn):                     
                                         
    def wrapper(*args, **kwargs):       # добавим необязательный список возможных именованных параметров         
        st = time.time()                
        res = fn(*args, **kwargs)       # возвратим вычисленное значение NOD, переменной res присвоим вычисленное значение fn 
        dt = time.time() - st           

        print(f"Время работы ф-ции с декоратором - @testTime_1 : {dt} сек")
        return res                      # когда все отработает возвратим значение res
    return wrapper  

@testTime_1             # пишем декоратор - перед нужной ф-цией в программе
def getNOD_1(a, b):
    while a != b:
        if a > b: a-= b
        else: b -= a
    return a

@testTime_1             # пишем декоратор - перед нужной ф-цией в программе
def getFastNOD_1(a, b):
    if a < b: a,b = b,a
    while b: a,b = b, a%b
    return a

res = getNOD_1(100000, 2)
print("Результат ф-ции getNOD_1: ",res)     # Определяем не только время работы ф-ции но и определяем вычесленное значение NOD

getFastNOD_1(100000,2)
print("Результат ф-ции getFastNOD_1: ", getFastNOD_1)

# если функция fn возвращает какое-либо значение, то это легко предусмотреть в обертке
# res = fn(*args, **kwargs)
# Определяем не только время работы ф-ции но и определяем вычесленное значение NOD
