# Структурное программирование - архитектурa программы
 # условие if
     # циклы: while, for
         # данные: строки, числа, списки

         
import random                  # подключили модуль - генератор случайных чисел 
N, M = (5, 10)                 # Размер игрового поля NxN и число мин M, сделаем для простоты глобальными

def getTotalMines(PM, i, j):   # 
    n = 0                      # счетчик мин равен 0
    for k in range(-1,2):      # цикл от -1 до 1
        for l in range(-1,2):  # цикл от -1 до 1
            x = i+k            # с помощью x и y будем перебирать все клетки, вокруг текущей
            y = j+l
            if x < 0 or x >= N or y < 0 or y >= N:   # проверка, если x и y будут выходить за пределы игрового поля,значит x , y в пределе игрового поля, 
                continue
            if PM[x*N+y] < 0:  #  значит есть мина, счетчик мин увеличиваем на 1
                n += 1
    return n                   # функция будет возвращать вычесленное значение n



            
def createGame(PM):            # поле нужно где-то создавать (располагать мины), появляется функция
    """Создание игрового поля: расположение мин
        и подсчет числа мин вокруг клеток без мин
    """

    rng = random.Random()      # через него будем генерировать псевдослучайные числа
    n = M                      # цикл, сколько мин, мы уже расставили, вспомогательной переменной n
    while n > 0:               # цикл, пока n > 0
        i = rng.randrange(N)   # случайное целое [0; N) - генерируем два числа, они будут попадать в предел игрового поля
        j = rng.randrange(N) 
        if PM[i*N+j] != 0:     # проверка, если стоит мина, клетка неравна 0, что-то уже поставили
                               # [i*N+j]- формула представления одномерного списка в виде двумерного i,j=0,1,2,...,N-1
            continue           # то ничегоделать не нужно, оператор continue
        PM[i*N+j] = -1         # иначе в эту клетку запишем -1
                               # [i*N+j] - формула представления одномерного списка в виде двумерного i,j=0,1,2,...,N-1
        n -= 1                 # счетчик n уменьшим на 1

    # вычисляем количество мин вокруг клетки
    for i in range(N):                                  # i будет пробегать от n до n-1
        for j in range(N):                              # j будет пробегать от n до n-1
            if PM[i*N+j] == 0:                          # проверка, если текущая позиция i,j == 0, значит пустая клетка без мины, 
                PM[i*N+j] = getTotalMines(PM, i, j)     # i,j присвоим значение вспомогательной функции, число мин будем расчитывать вокруг клетки с индексом i, j    


def show(pole):                # программист решает: нужна вспомогательная функция для отображения игрового поля и выше определяет ее
                               # функция отображения поля
    """Функция отображения состояния текущего
        игрового поля
    """
    for i in range(N):
        for j in range(N):
            print( str(pole[i*N+j]).rjust(3), end="" )  # выводим значение поля, которое будем передавать этой функции с индексами i, j, (сначала число преобразовываем в строку, потом для строки вызываем метод .rjust - форматный вывод данных, end - чтоб не было перевода на новую строку 
        print()                                         # делаем перевод на новую строку


def goPlayer():                # функция для ввода координат клетки игроком
    """Функция для ввода пользователем координат
        закрытой клетки игрового поля
    """
    flLoopInput = True         # изначально переменная True
    while flLoopInput:         # цикл пока пользователь не введет корректные данные 
        x, y = input("Введите координату через пробел: ").split()
        if not x.isdigit() or not y.isdigit():      # просим пользователя ввести две координаты целочисленных через пробел
            print("Координаты введены неверно")
            continue

        x = int(x) - 1  # если все ок, координаты x, y преобразуем в целое число, затем вычтем 1
        y = int(y) - 1  # предположим, пользователь вводит от 1 до N, в игре координаты от N до N-1, поэтому -1 и вычитаем
                        # проверим, выходят ли координаты за пределы поля
        if x < 0 or x >= N or y < 0 or y >= N:
            print("Координаты выходят за пределы поля")  # если координаты выходят
            continue

        flLoopInput = False  # если проверки нормально, для переменной устанавливаем False # цикл завершится
    return (x, y)  # возвратим координаты в виде кортежа
                                # проверка, правильно ли он ввел координаты
                                # если x, y это не цифры, значит пользователь ввел что-то не так
                                # continue - возвращает нас на начало цикла, и снова выполнится строчка x, y = input("Введите координату через пробел: ").split()
        



def isFinish(PM, P):           # функция проверки текущего состояния игры, счет
    """Определение текущего состояния игры:
        выиграли, проиграли, игра продолжается
    """
    for i in range(N*N):                            # счетчик i от 0 и до конца поля одномерного массива
        if P[i] != -2 and PM[i] < 0: return -1      # проверка, если наше поле P[i], что открывает игрок != -2, т.е. эта клетка открыта им. Клетка PM с индексом [i], принимает значение < 0:, значит игрок гаступил на мину, и мы возвращаем return -1   

    for i in range(N*N):   
        if P[i] == -2 and PM[i] >= 0: return 1     # проверка, если у нас текущая клетка не открыта равна -2 (== -2), и клетка РМ с индексом [i] принимает значение больше или равно >=0:, значит игорок не открыл еще все клетки, игра должна продолжаться мы возвращаем 1, return 1

    return -2                                       # если цикл прошел и не сработал, значит игрок открыл все клетки - мы возвратим -2
                                                    
def startGame():               # функция запуска игры в целом, с нее запуск (1-я итерация создания игры - верхний уровень) 
                               # вызывает все наши вспомогательные функции
    """Функция запуска игры: отображается игровое поле,
        игрок открывает любую закрытую клетку,
        результат проверяется на наличие мины или
        выигрышной ситуации
    """                        # help(startGame)
                               #  подумаем: как вызываемые функции вызывать в функции верхнего уровня startGame?
                               # должен быть цикл, в котором будет происходить последовательный их вызов
                               # пользователь будет постоянно выбирать последовательно клетки игрового поля
                               # они будут открываться, до тех пор пока он не откроет все поле, либо не наступит на мину
    P = [-2]*N*N               # одномерный список из -2  N на N элементов
    PM = [0]*N*N               # одномерный список из -2  N на N элементов                              

    createGame(PM)             # функция будет создавать игровое поле
                               # функция будет расставлять мины на поле PM  # PM нужно передать в качестве аргумента
  #  show(PM)                  # передали сформированное поле PM                                                // убираем после заполнения функции  def isFinish(PM, P):
  #  goPlayer()                #                                                                                // убираем после заполнения функции  def isFinish(PM, P):
    finishState = isFinish(PM, P)
    while finishState > 0:     # запишем формально цикл while -> условие окончание цикла функция isFinish       // передали два поля РМ, Р    // пока эта функция возвращает > 0, т.е 1, то игра продолжается, а если возвратит < 0 (-1, -2 , то игра завершена)
      show(P)                  # тело цикла - функция показать поле                                             // будет отображать поле P    
      x,y = goPlayer()         # функция попросить пользователя открыть определеннуюю клетку                    // будет отображать две координаты x, y

      P[x*N+y] = PM[x*N+y]     # после того как ввел координаты x, y - мы должны открыть клетку в игровом поле P         
      finishState = isFinish(PM, P)

    return finishState
                               # pass - тело функции - пустая заготовка (1-я итерация создания игры - верхний уровень)
res = startGame()              # вызвали эту функцию (1-я итерация создания игры - верхний уровень)
if res == -1:
     print ("Вы проиграли")
else:
     print ("Вы выиграли")

print("Игра завершена")        # вызвали эту функцию (1-я итерация создания игры - верхний уровень)

#  startGame() -> createGame() -> while isFinish() -> show() -> goPlayer()
# 1. у нас должно быть два списка: один с расположением мин и с числовыми значениями - PM, а второй для отображения текущего состояния игры - P
# 2. Далее, нужно решить где создать эти переменные: внутри функции startGame или глобальными в начале текста программы.
# 3. Так как глобальных переменных в любой программе должно быть минимум, то объявим их внутри startGame.
# 4. Поле P значение -2 - клетка еще не открыта.
# 5. Поля PM Значение -1 – стоит мина,
# 6. любое неотрицательное число у обеих списков – открытая клетка без мины и показывает мин вокруг нее.
# 7. Поле P - текущее состояние игры. Поле P значение -2 - клетка еще не открыта.
# 8. Поле P - отличное от -2 - значит ее открыли. Открыли клетку - значение 3, значит вокруг 3 мины

