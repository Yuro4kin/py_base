# Кортеж – это упорядоченная неизменяемая коллекция произвольных данных.
# Кортеж отличается от списка тем что он неизменяемый.
a = 1, 2
b = (1, 2, 3, 4, 5)
c = 1,
cc = (1,)
print(a, b, c, cc)
# переменные через запятую - присвоим значения из кортежа
x, y = (1, 2)
# d,e = (1,2,3)       # error

# len(a) - определения длины кортежа (числа его элементов)
lenB = len(b)
print(lenB)

# доступ к элементам кортежа осуществляется также как и к элементам списков:
# доступ к элементам кортежа - по индексу
searchInd = b[3]
print(b[-1])


# доступ к элементам кортежа - по срезам 
b[1:2]  # последний индекс среза не включается
b[0:1]  # возьмем все кроме последнего элемента
b[:3]   # указать начальное значение, возьмем первые три элемента
b[:]    # весь кортеж

d = b[:]  # переменная d ссылается на тот же кортеж, это не копирование
tupID = print(id(d), id(b))


# Кортеж - это неизменяемый тип
# a[1] = 100      # error - не можем определенному значению присвоить другое значение
# использовать кортеж, значит «запретить» программисту менять значения элементов списка


# Кортежи можно использовать в качестве ключей у словарей, например, так.
# Ключ у словарей
e = {}  # словарь e
e[a] = "кортеж"
print(e, type(e))
# {(1, 2): 'кортеж'}    # получим в итоге словарь e 



# Списки это изменяемый элемент, а ключами словарей могут быть неизменяемые элементы
# Поэтому кортежи хорошо подходят
# Кортеж занимает меньше памяти, чем такой же список
lst = [1, 2, 3]
tup = (1, 2, 3)
lstByte = lst.__sizeof__()  # размер любого объекта в памяти __sizeof__()
tupByte = tup.__sizeof__()



# операции с кортежами выполняются быстрее, чем со списками,
# например, перебор элементов или доступ к отдельному элементу.
# - если мы работаем с неизменяемым упорядоченным списком,
# то предпочтительнее использовать кортеж.

# Создать пустой кортеж
f = ()
g = tuple()
typeTuple = print(type(f), type(g))  # вывести тип переменных
# (<class 'tuple'>, <class 'tuple'>)


# Добавлять новые элементы в кортеж
h = ()
h = h + (1,)
h = (2, 3) + h               # добавить в начало к существующему кортежу
h += (("a", "hello"),)       # добавить вложенный кортеж
i = (0,) * 10                # кортеж состоит из 0, продублировать 10 раз
ii = ('hello', 'world') * 5  # дубли из слов



# функции tuple , list ( с списка в кортеж, с кортежа в список)
# функция tuple - создавать кортежи на основе любых упорядоченных списков
j = tuple([1, 2, 3])  # передали в качестве аргумента список
jj = tuple("Привет мир")  # передали строку, строка это КОЛЛЕКЦИЯ из символов


# обратная операция, из кортежа получим список - функция list
k = (1, 2, 3)
lstK = list(k)



# Виды данных для хранения кортежа
l1 = (True, [1, 2, 3], "hello", 5, {"house": "дом"})
# бул.перем. список,  строка, число,   словарь
print(l1)


# список – это изменяемый тип, следовательно,
# его значение даже в кортеже мы можем спокойно менять
# обратимся к элементу по индексу 1
print(l1[1])


# получили доступ по индексу 1 -[1,2,3] - это список, можем менять 
l2 = l1[1].append(5)
print(l2)


# неизменность кортежа к структуре и к ссылкам, которые ссылаются на соответствующие объекты
# значение ссылок менять не можем, можем менять объект, если он является изменяемым
# ссылка на объект неизменная


# не можем удалять отдельные элементы из кортежа
# del l[1]
# удалить весь кортеж мы можем
# del l


# Метод .count("abc") - найти элемент по его значению возвращает индекс первого найденного
l1.count("abc")         # 0
l1.count("hello")       # 1
l1.count(5)             # 1
l1.count('5')           # 0  - в списках не ищет [1,2,3]
print(l1.count('5'))


# Метод .index("abc") - найти элемент по его значению - возвращает индекс элемента
l1.index([1, 2, 3, 5])  # 1 - index элемента
l1.index(5)             # 3 - index элемента
# l.index(0)            # error - нет элемента
l1.index(5, 3)          # второй аргумент говорит, с какого индекса иы буем начинать искать
l1.index(5, 3, 4)       # с какого индекса и по который будем искать
print(l1.index(5, 3, 4))


