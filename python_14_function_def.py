# Собственные функции - def , синтаксис
# Главное задание функции - многократное выполнение определенного фрагмента программы

# def <имя функции>([список аргументов]):
#       оператор 1          - 
#       оператор 2          - yнабор операторов, когда выполняется функция - это тело функции
#       …                   -
#       оператор N          - 

# Функция - это определенные действия - go, show, get, set ...
def sayHello():
    print("hello")

sayHello()              # () - оператор вызова функции с указанным именем

sayHello                # ссылка на объект, который представляет функцию
print( type(sayHello) ) # тип объекта - <class 'function'>
                        # ссылка на специальный объект, представляющий ту или иную функцию

# Когда объявляем с таким синтаксисом функцию, то фактически создаем объект с именем
# Имя будет ссылаться на функцию
# значит sayHello - это ссылка

# вызвать функцию через второе имя
f = sayHello
f()                     # <function sayHello at 0x000001EC40970B80>

print("--------------------")
sayHello()              # повторный вызов функции с указанным именем

# вызывать функцию можно столько раз, сколько необходимо

# вызывать функцию можно только после определения  def sayHello():
                                                       # print("hello")
# определение функции - в начале текста прогаммы

# функция вычисления модуля числа
def myModulNum(x):
    x = -x if (x < 0) else x  # тернарный условный оператор
    return x                  # x - функция возвращает

print( myModulNum(-5) )

# myModulNum(x): Когда мы вызываем функцию myModulNumю, x начинает ссылаться на аргумент -5
# -5 < 0 - выполняется условие (ставим "-" перед -5) получаем +5, формируется новый объект со значением 5
# теперь x ссылается на новый объект
# Если бы условие изменилось, x - ссылка продолжала бы указывать на этот объект
# return - возвращает ссылку x
# x - делает работу функции универсальной с любыми числовыми данными

numA = -100
print( myModulNum(numA) )

# return x - после этого оператора, ничего не выводится, до него выводится
# return x = break в циклах, как только встретился, завершил работу
# return x - завершает работу функции

numB = myModulNum(-5.8)
print(numB)

# функция определения положительного или отрицательного числа
def isPositive(y):
    if y >= 0:               
        return True         # этого можно не писать, т.к. по умолчанию True 
    else:
        return False        # этого можно не писать, т.к. по умолчанию False
# формируем список только положительных значений
a = []
for b in range(-5, 11):             # переменная b пробегает значение от -5 дл 10
    if isPositive(b):               # проверка, если b положительная, то мы это значение добавляем в список a  
        a.append(b)
print(a)

# Функция вычисления периметра прямоугольника - принимает два аргумента(фактические параметры)
def getSquare(w, h):
    return 2*(w + h)
p = getSquare(10, 5.5)      # 10 ссылается на w, 5.5 ссылается на h
print(p)                    # по такому признаку у функции можно определять различные число аргументов

# Функция с формальными параметрами, значения по умолчанию
# def sayHello(msg, end + "!", sep = ":"):
# msg - факт парам, end_sep - форм. парам.
def SayBye(msg, end="!"):
    print(msg + end)
    
SayBye("Bye")              # с одним параметром
SayBye("Bye", "?")         # с двумя параметрами
# Если формальное значение не указано при вызове функции, то берется значение по умолчанию "!"
# Если указали другое, то на него ссылается переменная "?"

# Функция с формальными параметрами, значения по умолчанию
# def sayHello(msg, end + "!", sep = ":"):
# msg - факт парам, end_sep - форм. парам.
def sayBye(msg1, end1="!", sep=": "):
    print("Message"+sep+msg1+end1)
    
sayBye("Bye")               # функцию можно вызывать с разным числом аргументов - с тремя параметрами
sayBye("Bye", "?")
sayBye("Bye", "?", " ")     # каждому перечисляемому значению соответствет своя переменная

sayBye("Bye", sep="_ _")    # вызов первого и последнего значения функции
                            # sep - именованый параметр, указали значение и имя

# функция с возращением нескольких значений (периметр и площадь прямоугольника)
def calcPerSq(width, height):
    return 2*(width + height), width*height     # функция в виде кортежа возвращает сразу несколько значений
result = calcPerSq(2.3, 5)
print(result)
# значение кортежа можно прописать в print
per, sq = calcPerSq(3.3, 6)
print(per, sq)

# return - возвращает самые разные типы данных и списки и словари, строки, числа

# функция myPow возводит число z в целую степень n
def myPow(z, n):
    sz = 1                  # вначале берем sz = 1
    while n > 0:            # если n > 0, начинаем вычислять произведения
        sz *= z             # z самого на себя n раз
        n -= 1              # n уменьшается на 1. Когда n=0, цикл завершается 
    return sz               # возвращается вычисленное значение

calcMyPow = myPow(3, 5)
print(calcMyPow)


# Переопределять существующие функции
def theySayHello():
    print("hello")
theySayHello()

def theySayHello():
    print("----hello-----")         # переопределение функции
theySayHello()

def theySayHello(msg1):
    print(msg1)                     # переопределение функции с аргументом
#theySayHello()                     # error - аргумент обязательно нужно указывать
theySayHello("def_function")

# Переопределение функции
# Если мы хотим определить некоторую функцию в зависимости от условия
TYPE_FUNC = False             # = False - Глобальная переменная, принимает значение True

if TYPE_FUNC:
    def sayHi():              # Если глобальная переменная TYPE_FUNC = True 
        print("hi")
else:
    def sayHi(msg2):          # Если глобальная переменная TYPE_FUNC = False
        print(msg2)

sayHi("Hi everybody")         # Если глобальная переменную определили = False
#sayHi()                       # Если глобальная переменную определили = True  

# Элементы функционального подохда к программированию
# Функциональное программирование
# Пример: функция, которая находит максимальное значение из двух чисел

def max2 (m, p):              # два числа из которых будем находить max 
    if m > p:
        return m              # m > p, возвращает m
    else:
        return p              # иначе, возвращает p

print( max2(2, -3) )          # вызов функции максимально из 2

# Пример: функция, которая находит максимальное значение из трех чисел
# добавляем функцию def max3 - вычисляет max среди 3 чисел, но использует функцию max2

def max3(m, p, c):
    return max2(m, max2(p, c))
   # - return функция max2 от аргумента m
   # - (второй аргумент вызов функции max2 от аргументов p, c) 
   # оператор return  возвращает значение функции max2 
   # прежде должна быть вызвана функция max2(p, c) с двумя аргументами
   # max среди р,с, - сюда передается max, затем max между m и p или c

print( max3(11, 2.2, -3) ) 

# Большую задачу, разбиваем на множество мелких, и каждую задачу решает своя собственная функция
# затем их вызываем и получается решение крупной задачи
print( max3('ab', 'cd', 'abc') )

# m, p, c - переменные не имеют определенного типа (сравнивать можно любые значения)
# m, p, c - переменные могут ссылаться на разные объекты, сравнивать можно различные типы данных



